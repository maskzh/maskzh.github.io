{"componentChunkName":"component---gatsby-theme-maskzh-src-templates-blog-post-tsx","path":"/zh/Dockerfile中ENTRYPOINT与CMD的区别/","result":{"data":{"site":{"siteMetadata":{"title":"ZYC's Blog"}},"markdownRemark":{"html":"<p>两条指令的区别是指定的命令是否在 shell 中被调用。</p>\n<ol>\n<li><code>ENTRYPOINT [\"node\", \"app.js\"]</code>，exec 形式</li>\n<li><code>ENTRYPOINT node app.js</code>，shell 形式</li>\n</ol>\n<p>如果使用 exec 形式的 ENTRYPOINT 指令：</p>\n<div class=\"gatsby-highlight\" data-language=\"docker\"><pre class=\"language-docker\"><code class=\"language-docker\"><span class=\"token keyword\">ENTRYPOINT</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"node\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"app.js\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>可以从容器中的运行进程列表看出：这里是直接运行 node 进程，而并非在 shell 中执行。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ docker exec 4675d ps x\n\tPID TTY     STAT TIME COMMAND\n\t1   ?       Ssl  0:00 node app.js\n\t2   ?       Rs   0:00 ps x</code></pre></div>\n<p>如果采用 shell 形式的指令：</p>\n<div class=\"gatsby-highlight\" data-language=\"docker\"><pre class=\"language-docker\"><code class=\"language-docker\"><span class=\"token keyword\">ENTRYPOINT</span> node app.js</code></pre></div>\n<p>则进程列表是这样：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ docker exec 4675d ps x\n\tPID TTY     STAT TIME COMMAND\n\t1   ?       Ss   0:00 /bin/sh -c node app.js\n\t7   ?       Sl   0:00 node app.js\n\t13  ?       Rs+  0:00 ps x</code></pre></div>\n<p>可以看出，主进程（PID 1）是 shell 进程而非 node 进程。</p>\n<p><strong>总结：shell 进程往往是多余的，因此通常使用 exec 形式的 ENTRYPOINT 指令。</strong></p>","rawMarkdownBody":"\n两条指令的区别是指定的命令是否在 shell 中被调用。\n\n1. `ENTRYPOINT [\"node\", \"app.js\"]`，exec 形式\n2. `ENTRYPOINT node app.js`，shell 形式\n\n如果使用 exec 形式的 ENTRYPOINT 指令：\n\n```docker\nENTRYPOINT [\"node\", \"app.js\"]\n```\n\n可以从容器中的运行进程列表看出：这里是直接运行 node 进程，而并非在 shell 中执行。\n\n```\n$ docker exec 4675d ps x\n\tPID TTY     STAT TIME COMMAND\n\t1   ?       Ssl  0:00 node app.js\n\t2   ?       Rs   0:00 ps x\n```\n\n如果采用 shell 形式的指令：\n\n```docker\nENTRYPOINT node app.js\n```\n\n则进程列表是这样：\n\n```\n$ docker exec 4675d ps x\n\tPID TTY     STAT TIME COMMAND\n\t1   ?       Ss   0:00 /bin/sh -c node app.js\n\t7   ?       Sl   0:00 node app.js\n\t13  ?       Rs+  0:00 ps x\n```\n\n可以看出，主进程（PID 1）是 shell 进程而非 node 进程。\n\n**总结：shell 进程往往是多余的，因此通常使用 exec 形式的 ENTRYPOINT 指令。**\n","timeToRead":1,"wordCount":{"paragraphs":9,"sentences":9,"words":40},"frontmatter":{"title":"Dockerfile 中 ENTRYPOINT 与 CMD 的区别","tags":["Tech/Docker"],"created":"2020-07-22"}}},"pageContext":{"slug":"/Dockerfile中ENTRYPOINT与CMD的区别/","language":"zh","i18n":{"language":"zh","languages":["en","zh"],"defaultLanguage":"en","routed":true,"resources":{"zh":{"translation":{"home":"首页","not found":"找不到该页面","create date":"创建日期","search articles":"搜索","articles":"文章列表"}}},"originalPath":"/Dockerfile中ENTRYPOINT与CMD的区别/","path":"zh/Dockerfile中ENTRYPOINT与CMD的区别/"}}},"staticQueryHashes":["1985809839","1985809839","63159454"]}